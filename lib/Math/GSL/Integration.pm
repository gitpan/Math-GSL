# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.36
#
# Don't modify this file, modify the SWIG interface instead.

package Math::GSL::Integration;
use base qw(Exporter);
use base qw(DynaLoader);
package Math::GSL::Integrationc;
bootstrap Math::GSL::Integration;
package Math::GSL::Integration;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Math::GSL::Integration;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Math::GSL::Integration;

*gsl_integration_workspace_alloc = *Math::GSL::Integrationc::gsl_integration_workspace_alloc;
*gsl_integration_workspace_free = *Math::GSL::Integrationc::gsl_integration_workspace_free;
*gsl_integration_qaws_table_alloc = *Math::GSL::Integrationc::gsl_integration_qaws_table_alloc;
*gsl_integration_qaws_table_set = *Math::GSL::Integrationc::gsl_integration_qaws_table_set;
*gsl_integration_qaws_table_free = *Math::GSL::Integrationc::gsl_integration_qaws_table_free;
*gsl_integration_qawo_table_alloc = *Math::GSL::Integrationc::gsl_integration_qawo_table_alloc;
*gsl_integration_qawo_table_set = *Math::GSL::Integrationc::gsl_integration_qawo_table_set;
*gsl_integration_qawo_table_set_length = *Math::GSL::Integrationc::gsl_integration_qawo_table_set_length;
*gsl_integration_qawo_table_free = *Math::GSL::Integrationc::gsl_integration_qawo_table_free;
*gsl_integration_qk15 = *Math::GSL::Integrationc::gsl_integration_qk15;
*gsl_integration_qk21 = *Math::GSL::Integrationc::gsl_integration_qk21;
*gsl_integration_qk31 = *Math::GSL::Integrationc::gsl_integration_qk31;
*gsl_integration_qk41 = *Math::GSL::Integrationc::gsl_integration_qk41;
*gsl_integration_qk51 = *Math::GSL::Integrationc::gsl_integration_qk51;
*gsl_integration_qk61 = *Math::GSL::Integrationc::gsl_integration_qk61;
*gsl_integration_qcheb = *Math::GSL::Integrationc::gsl_integration_qcheb;
*gsl_integration_qk = *Math::GSL::Integrationc::gsl_integration_qk;
*gsl_integration_qng = *Math::GSL::Integrationc::gsl_integration_qng;
*gsl_integration_qag = *Math::GSL::Integrationc::gsl_integration_qag;
*gsl_integration_qagi = *Math::GSL::Integrationc::gsl_integration_qagi;
*gsl_integration_qagiu = *Math::GSL::Integrationc::gsl_integration_qagiu;
*gsl_integration_qagil = *Math::GSL::Integrationc::gsl_integration_qagil;
*gsl_integration_qags = *Math::GSL::Integrationc::gsl_integration_qags;
*gsl_integration_qagp = *Math::GSL::Integrationc::gsl_integration_qagp;
*gsl_integration_qawc = *Math::GSL::Integrationc::gsl_integration_qawc;
*gsl_integration_qaws = *Math::GSL::Integrationc::gsl_integration_qaws;
*gsl_integration_qawo = *Math::GSL::Integrationc::gsl_integration_qawo;
*gsl_integration_qawf = *Math::GSL::Integrationc::gsl_integration_qawf;

############# Class : Math::GSL::Integration::gsl_integration_workspace ##############

package Math::GSL::Integration::gsl_integration_workspace;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::Integration );
%OWNER = ();
%ITERATORS = ();
*swig_limit_get = *Math::GSL::Integrationc::gsl_integration_workspace_limit_get;
*swig_limit_set = *Math::GSL::Integrationc::gsl_integration_workspace_limit_set;
*swig_size_get = *Math::GSL::Integrationc::gsl_integration_workspace_size_get;
*swig_size_set = *Math::GSL::Integrationc::gsl_integration_workspace_size_set;
*swig_nrmax_get = *Math::GSL::Integrationc::gsl_integration_workspace_nrmax_get;
*swig_nrmax_set = *Math::GSL::Integrationc::gsl_integration_workspace_nrmax_set;
*swig_i_get = *Math::GSL::Integrationc::gsl_integration_workspace_i_get;
*swig_i_set = *Math::GSL::Integrationc::gsl_integration_workspace_i_set;
*swig_maximum_level_get = *Math::GSL::Integrationc::gsl_integration_workspace_maximum_level_get;
*swig_maximum_level_set = *Math::GSL::Integrationc::gsl_integration_workspace_maximum_level_set;
*swig_alist_get = *Math::GSL::Integrationc::gsl_integration_workspace_alist_get;
*swig_alist_set = *Math::GSL::Integrationc::gsl_integration_workspace_alist_set;
*swig_blist_get = *Math::GSL::Integrationc::gsl_integration_workspace_blist_get;
*swig_blist_set = *Math::GSL::Integrationc::gsl_integration_workspace_blist_set;
*swig_rlist_get = *Math::GSL::Integrationc::gsl_integration_workspace_rlist_get;
*swig_rlist_set = *Math::GSL::Integrationc::gsl_integration_workspace_rlist_set;
*swig_elist_get = *Math::GSL::Integrationc::gsl_integration_workspace_elist_get;
*swig_elist_set = *Math::GSL::Integrationc::gsl_integration_workspace_elist_set;
*swig_order_get = *Math::GSL::Integrationc::gsl_integration_workspace_order_get;
*swig_order_set = *Math::GSL::Integrationc::gsl_integration_workspace_order_set;
*swig_level_get = *Math::GSL::Integrationc::gsl_integration_workspace_level_get;
*swig_level_set = *Math::GSL::Integrationc::gsl_integration_workspace_level_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::Integrationc::new_gsl_integration_workspace(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::Integrationc::delete_gsl_integration_workspace($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::Integration::gsl_integration_qaws_table ##############

package Math::GSL::Integration::gsl_integration_qaws_table;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::Integration );
%OWNER = ();
%ITERATORS = ();
*swig_alpha_get = *Math::GSL::Integrationc::gsl_integration_qaws_table_alpha_get;
*swig_alpha_set = *Math::GSL::Integrationc::gsl_integration_qaws_table_alpha_set;
*swig_beta_get = *Math::GSL::Integrationc::gsl_integration_qaws_table_beta_get;
*swig_beta_set = *Math::GSL::Integrationc::gsl_integration_qaws_table_beta_set;
*swig_mu_get = *Math::GSL::Integrationc::gsl_integration_qaws_table_mu_get;
*swig_mu_set = *Math::GSL::Integrationc::gsl_integration_qaws_table_mu_set;
*swig_nu_get = *Math::GSL::Integrationc::gsl_integration_qaws_table_nu_get;
*swig_nu_set = *Math::GSL::Integrationc::gsl_integration_qaws_table_nu_set;
*swig_ri_get = *Math::GSL::Integrationc::gsl_integration_qaws_table_ri_get;
*swig_ri_set = *Math::GSL::Integrationc::gsl_integration_qaws_table_ri_set;
*swig_rj_get = *Math::GSL::Integrationc::gsl_integration_qaws_table_rj_get;
*swig_rj_set = *Math::GSL::Integrationc::gsl_integration_qaws_table_rj_set;
*swig_rg_get = *Math::GSL::Integrationc::gsl_integration_qaws_table_rg_get;
*swig_rg_set = *Math::GSL::Integrationc::gsl_integration_qaws_table_rg_set;
*swig_rh_get = *Math::GSL::Integrationc::gsl_integration_qaws_table_rh_get;
*swig_rh_set = *Math::GSL::Integrationc::gsl_integration_qaws_table_rh_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::Integrationc::new_gsl_integration_qaws_table(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::Integrationc::delete_gsl_integration_qaws_table($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::Integration::gsl_integration_qawo_table ##############

package Math::GSL::Integration::gsl_integration_qawo_table;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::Integration );
%OWNER = ();
%ITERATORS = ();
*swig_n_get = *Math::GSL::Integrationc::gsl_integration_qawo_table_n_get;
*swig_n_set = *Math::GSL::Integrationc::gsl_integration_qawo_table_n_set;
*swig_omega_get = *Math::GSL::Integrationc::gsl_integration_qawo_table_omega_get;
*swig_omega_set = *Math::GSL::Integrationc::gsl_integration_qawo_table_omega_set;
*swig_L_get = *Math::GSL::Integrationc::gsl_integration_qawo_table_L_get;
*swig_L_set = *Math::GSL::Integrationc::gsl_integration_qawo_table_L_set;
*swig_par_get = *Math::GSL::Integrationc::gsl_integration_qawo_table_par_get;
*swig_par_set = *Math::GSL::Integrationc::gsl_integration_qawo_table_par_set;
*swig_sine_get = *Math::GSL::Integrationc::gsl_integration_qawo_table_sine_get;
*swig_sine_set = *Math::GSL::Integrationc::gsl_integration_qawo_table_sine_set;
*swig_chebmo_get = *Math::GSL::Integrationc::gsl_integration_qawo_table_chebmo_get;
*swig_chebmo_set = *Math::GSL::Integrationc::gsl_integration_qawo_table_chebmo_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::Integrationc::new_gsl_integration_qawo_table(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::Integrationc::delete_gsl_integration_qawo_table($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package Math::GSL::Integration;

*GSL_INTEG_COSINE = *Math::GSL::Integrationc::GSL_INTEG_COSINE;
*GSL_INTEG_SINE = *Math::GSL::Integrationc::GSL_INTEG_SINE;
*GSL_INTEG_GAUSS15 = *Math::GSL::Integrationc::GSL_INTEG_GAUSS15;
*GSL_INTEG_GAUSS21 = *Math::GSL::Integrationc::GSL_INTEG_GAUSS21;
*GSL_INTEG_GAUSS31 = *Math::GSL::Integrationc::GSL_INTEG_GAUSS31;
*GSL_INTEG_GAUSS41 = *Math::GSL::Integrationc::GSL_INTEG_GAUSS41;
*GSL_INTEG_GAUSS51 = *Math::GSL::Integrationc::GSL_INTEG_GAUSS51;
*GSL_INTEG_GAUSS61 = *Math::GSL::Integrationc::GSL_INTEG_GAUSS61;

@EXPORT_OK = qw/
               gsl_integration_workspace_alloc 
               gsl_integration_workspace_free 
               gsl_integration_qaws_table_alloc 
               gsl_integration_qaws_table_set 
               gsl_integration_qaws_table_free 
               gsl_integration_qawo_table_alloc 
               gsl_integration_qawo_table_set 
               gsl_integration_qawo_table_set_length 
               gsl_integration_qawo_table_free 
               gsl_integration_qk15 
               gsl_integration_qk21 
               gsl_integration_qk31 
               gsl_integration_qk41 
               gsl_integration_qk51 
               gsl_integration_qk61 
               gsl_integration_qcheb 
               gsl_integration_qk 
               gsl_integration_qng 
               gsl_integration_qag 
               gsl_integration_qagi 
               gsl_integration_qagiu 
               gsl_integration_qagil 
               gsl_integration_qags 
               gsl_integration_qagp 
               gsl_integration_qawc 
               gsl_integration_qaws 
               gsl_integration_qawo 
               gsl_integration_qawf 
               $GSL_INTEG_COSINE 
               $GSL_INTEG_SINE 
               $GSL_INTEG_GAUSS15 
               $GSL_INTEG_GAUSS21 
               $GSL_INTEG_GAUSS31 
               $GSL_INTEG_GAUSS41 
               $GSL_INTEG_GAUSS51 
               $GSL_INTEG_GAUSS61 
             /;
%EXPORT_TAGS = ( all => [ @EXPORT_OK ] );

__END__

=head1 NAME

Math::GSL::Integration - Routines for performing numerical integration (quadrature) of a function in one dimension

=head1 SYNOPSIS

This module is not yet implemented. Patches Welcome!

use Math::GSL::Integration qw /:all/;

=head1 DESCRIPTION

Here is a list of all the functions in this module :

=over 

=item * C<gsl_integration_workspace_alloc >

=item * C<gsl_integration_workspace_free >

=item * C<gsl_integration_qaws_table_alloc >

=item * C<gsl_integration_qaws_table_set >

=item * C<gsl_integration_qaws_table_free >

=item * C<gsl_integration_qawo_table_alloc >

=item * C<gsl_integration_qawo_table_set >

=item * C<gsl_integration_qawo_table_set_length >

=item * C<gsl_integration_qawo_table_free >

=item * C<gsl_integration_qk15 >

=item * C<gsl_integration_qk21 >

=item * C<gsl_integration_qk31 >

=item * C<gsl_integration_qk41 >

=item * C<gsl_integration_qk51 >

=item * C<gsl_integration_qk61 >

=item * C<gsl_integration_qcheb >

=item * C<gsl_integration_qk >

=item * C<gsl_integration_qng >

=item * C<gsl_integration_qag >

=item * C<gsl_integration_qagi >

=item * C<gsl_integration_qagiu >

=item * C<gsl_integration_qagil >

=item * C<gsl_integration_qags >

=item * C<gsl_integration_qagp >

=item * C<gsl_integration_qawc >

=item * C<gsl_integration_qaws >

=item * C<gsl_integration_qawo >

=item * C<gsl_integration_qawf >

=back

This module also includes the following constants :

=over

=item * $GSL_INTEG_COSINE 

=item * $GSL_INTEG_SINE 

=item * $GSL_INTEG_GAUSS15 

=item * $GSL_INTEG_GAUSS21 

=item * $GSL_INTEG_GAUSS31 

=item * $GSL_INTEG_GAUSS41 

=item * $GSL_INTEG_GAUSS51 

=item * $GSL_INTEG_GAUSS61 

=back

For more informations on the functions, we refer you to the GSL offcial
documentation: L<http://www.gnu.org/software/gsl/manual/html_node/>

Tip : search on google: site:http://www.gnu.org/software/gsl/manual/html_node/ name_of_the_function_you_want


=head1 AUTHORS

Jonathan Leto <jonathan@leto.net> and Thierry Moisan <thierry.moisan@gmail.com>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2008 Jonathan Leto and Thierry Moisan

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

1;
