# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.36
#
# Don't modify this file, modify the SWIG interface instead.

package Math::GSL::Integration;
use base qw(Exporter);
use base qw(DynaLoader);
package Math::GSL::Integrationc;
bootstrap Math::GSL::Integration;
package Math::GSL::Integration;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Math::GSL::Integration;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Math::GSL::Integration;

*gsl_integration_workspace_alloc = *Math::GSL::Integrationc::gsl_integration_workspace_alloc;
*gsl_integration_workspace_free = *Math::GSL::Integrationc::gsl_integration_workspace_free;
*gsl_integration_qaws_table_alloc = *Math::GSL::Integrationc::gsl_integration_qaws_table_alloc;
*gsl_integration_qaws_table_set = *Math::GSL::Integrationc::gsl_integration_qaws_table_set;
*gsl_integration_qaws_table_free = *Math::GSL::Integrationc::gsl_integration_qaws_table_free;
*gsl_integration_qawo_table_alloc = *Math::GSL::Integrationc::gsl_integration_qawo_table_alloc;
*gsl_integration_qawo_table_set = *Math::GSL::Integrationc::gsl_integration_qawo_table_set;
*gsl_integration_qawo_table_set_length = *Math::GSL::Integrationc::gsl_integration_qawo_table_set_length;
*gsl_integration_qawo_table_free = *Math::GSL::Integrationc::gsl_integration_qawo_table_free;
*gsl_integration_qk15 = *Math::GSL::Integrationc::gsl_integration_qk15;
*gsl_integration_qk21 = *Math::GSL::Integrationc::gsl_integration_qk21;
*gsl_integration_qk31 = *Math::GSL::Integrationc::gsl_integration_qk31;
*gsl_integration_qk41 = *Math::GSL::Integrationc::gsl_integration_qk41;
*gsl_integration_qk51 = *Math::GSL::Integrationc::gsl_integration_qk51;
*gsl_integration_qk61 = *Math::GSL::Integrationc::gsl_integration_qk61;
*gsl_integration_qcheb = *Math::GSL::Integrationc::gsl_integration_qcheb;
*gsl_integration_qk = *Math::GSL::Integrationc::gsl_integration_qk;
*gsl_integration_qng = *Math::GSL::Integrationc::gsl_integration_qng;
*gsl_integration_qag = *Math::GSL::Integrationc::gsl_integration_qag;
*gsl_integration_qagi = *Math::GSL::Integrationc::gsl_integration_qagi;
*gsl_integration_qagiu = *Math::GSL::Integrationc::gsl_integration_qagiu;
*gsl_integration_qagil = *Math::GSL::Integrationc::gsl_integration_qagil;
*gsl_integration_qags = *Math::GSL::Integrationc::gsl_integration_qags;
*gsl_integration_qagp = *Math::GSL::Integrationc::gsl_integration_qagp;
*gsl_integration_qawc = *Math::GSL::Integrationc::gsl_integration_qawc;
*gsl_integration_qaws = *Math::GSL::Integrationc::gsl_integration_qaws;
*gsl_integration_qawo = *Math::GSL::Integrationc::gsl_integration_qawo;
*gsl_integration_qawf = *Math::GSL::Integrationc::gsl_integration_qawf;

############# Class : Math::GSL::Integration::gsl_integration_workspace ##############

package Math::GSL::Integration::gsl_integration_workspace;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::Integration );
%OWNER = ();
%ITERATORS = ();
*swig_limit_get = *Math::GSL::Integrationc::gsl_integration_workspace_limit_get;
*swig_limit_set = *Math::GSL::Integrationc::gsl_integration_workspace_limit_set;
*swig_size_get = *Math::GSL::Integrationc::gsl_integration_workspace_size_get;
*swig_size_set = *Math::GSL::Integrationc::gsl_integration_workspace_size_set;
*swig_nrmax_get = *Math::GSL::Integrationc::gsl_integration_workspace_nrmax_get;
*swig_nrmax_set = *Math::GSL::Integrationc::gsl_integration_workspace_nrmax_set;
*swig_i_get = *Math::GSL::Integrationc::gsl_integration_workspace_i_get;
*swig_i_set = *Math::GSL::Integrationc::gsl_integration_workspace_i_set;
*swig_maximum_level_get = *Math::GSL::Integrationc::gsl_integration_workspace_maximum_level_get;
*swig_maximum_level_set = *Math::GSL::Integrationc::gsl_integration_workspace_maximum_level_set;
*swig_alist_get = *Math::GSL::Integrationc::gsl_integration_workspace_alist_get;
*swig_alist_set = *Math::GSL::Integrationc::gsl_integration_workspace_alist_set;
*swig_blist_get = *Math::GSL::Integrationc::gsl_integration_workspace_blist_get;
*swig_blist_set = *Math::GSL::Integrationc::gsl_integration_workspace_blist_set;
*swig_rlist_get = *Math::GSL::Integrationc::gsl_integration_workspace_rlist_get;
*swig_rlist_set = *Math::GSL::Integrationc::gsl_integration_workspace_rlist_set;
*swig_elist_get = *Math::GSL::Integrationc::gsl_integration_workspace_elist_get;
*swig_elist_set = *Math::GSL::Integrationc::gsl_integration_workspace_elist_set;
*swig_order_get = *Math::GSL::Integrationc::gsl_integration_workspace_order_get;
*swig_order_set = *Math::GSL::Integrationc::gsl_integration_workspace_order_set;
*swig_level_get = *Math::GSL::Integrationc::gsl_integration_workspace_level_get;
*swig_level_set = *Math::GSL::Integrationc::gsl_integration_workspace_level_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::Integrationc::new_gsl_integration_workspace(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::Integrationc::delete_gsl_integration_workspace($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::Integration::gsl_integration_qaws_table ##############

package Math::GSL::Integration::gsl_integration_qaws_table;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::Integration );
%OWNER = ();
%ITERATORS = ();
*swig_alpha_get = *Math::GSL::Integrationc::gsl_integration_qaws_table_alpha_get;
*swig_alpha_set = *Math::GSL::Integrationc::gsl_integration_qaws_table_alpha_set;
*swig_beta_get = *Math::GSL::Integrationc::gsl_integration_qaws_table_beta_get;
*swig_beta_set = *Math::GSL::Integrationc::gsl_integration_qaws_table_beta_set;
*swig_mu_get = *Math::GSL::Integrationc::gsl_integration_qaws_table_mu_get;
*swig_mu_set = *Math::GSL::Integrationc::gsl_integration_qaws_table_mu_set;
*swig_nu_get = *Math::GSL::Integrationc::gsl_integration_qaws_table_nu_get;
*swig_nu_set = *Math::GSL::Integrationc::gsl_integration_qaws_table_nu_set;
*swig_ri_get = *Math::GSL::Integrationc::gsl_integration_qaws_table_ri_get;
*swig_ri_set = *Math::GSL::Integrationc::gsl_integration_qaws_table_ri_set;
*swig_rj_get = *Math::GSL::Integrationc::gsl_integration_qaws_table_rj_get;
*swig_rj_set = *Math::GSL::Integrationc::gsl_integration_qaws_table_rj_set;
*swig_rg_get = *Math::GSL::Integrationc::gsl_integration_qaws_table_rg_get;
*swig_rg_set = *Math::GSL::Integrationc::gsl_integration_qaws_table_rg_set;
*swig_rh_get = *Math::GSL::Integrationc::gsl_integration_qaws_table_rh_get;
*swig_rh_set = *Math::GSL::Integrationc::gsl_integration_qaws_table_rh_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::Integrationc::new_gsl_integration_qaws_table(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::Integrationc::delete_gsl_integration_qaws_table($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::Integration::gsl_integration_qawo_table ##############

package Math::GSL::Integration::gsl_integration_qawo_table;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::Integration );
%OWNER = ();
%ITERATORS = ();
*swig_n_get = *Math::GSL::Integrationc::gsl_integration_qawo_table_n_get;
*swig_n_set = *Math::GSL::Integrationc::gsl_integration_qawo_table_n_set;
*swig_omega_get = *Math::GSL::Integrationc::gsl_integration_qawo_table_omega_get;
*swig_omega_set = *Math::GSL::Integrationc::gsl_integration_qawo_table_omega_set;
*swig_L_get = *Math::GSL::Integrationc::gsl_integration_qawo_table_L_get;
*swig_L_set = *Math::GSL::Integrationc::gsl_integration_qawo_table_L_set;
*swig_par_get = *Math::GSL::Integrationc::gsl_integration_qawo_table_par_get;
*swig_par_set = *Math::GSL::Integrationc::gsl_integration_qawo_table_par_set;
*swig_sine_get = *Math::GSL::Integrationc::gsl_integration_qawo_table_sine_get;
*swig_sine_set = *Math::GSL::Integrationc::gsl_integration_qawo_table_sine_set;
*swig_chebmo_get = *Math::GSL::Integrationc::gsl_integration_qawo_table_chebmo_get;
*swig_chebmo_set = *Math::GSL::Integrationc::gsl_integration_qawo_table_chebmo_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::Integrationc::new_gsl_integration_qawo_table(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::Integrationc::delete_gsl_integration_qawo_table($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package Math::GSL::Integration;

*GSL_INTEG_COSINE = *Math::GSL::Integrationc::GSL_INTEG_COSINE;
*GSL_INTEG_SINE = *Math::GSL::Integrationc::GSL_INTEG_SINE;
*GSL_INTEG_GAUSS15 = *Math::GSL::Integrationc::GSL_INTEG_GAUSS15;
*GSL_INTEG_GAUSS21 = *Math::GSL::Integrationc::GSL_INTEG_GAUSS21;
*GSL_INTEG_GAUSS31 = *Math::GSL::Integrationc::GSL_INTEG_GAUSS31;
*GSL_INTEG_GAUSS41 = *Math::GSL::Integrationc::GSL_INTEG_GAUSS41;
*GSL_INTEG_GAUSS51 = *Math::GSL::Integrationc::GSL_INTEG_GAUSS51;
*GSL_INTEG_GAUSS61 = *Math::GSL::Integrationc::GSL_INTEG_GAUSS61;

@EXPORT_OK = qw/
               gsl_integration_workspace_alloc 
               gsl_integration_workspace_free 
               gsl_integration_qaws_table_alloc 
               gsl_integration_qaws_table_set 
               gsl_integration_qaws_table_free 
               gsl_integration_qawo_table_alloc 
               gsl_integration_qawo_table_set 
               gsl_integration_qawo_table_set_length 
               gsl_integration_qawo_table_free 
               gsl_integration_qk15 
               gsl_integration_qk21 
               gsl_integration_qk31 
               gsl_integration_qk41 
               gsl_integration_qk51 
               gsl_integration_qk61 
               gsl_integration_qcheb 
               gsl_integration_qk 
               gsl_integration_qng 
               gsl_integration_qag 
               gsl_integration_qagi 
               gsl_integration_qagiu 
               gsl_integration_qagil 
               gsl_integration_qags 
               gsl_integration_qagp 
               gsl_integration_qawc 
               gsl_integration_qaws 
               gsl_integration_qawo 
               gsl_integration_qawf 
               $GSL_INTEG_COSINE 
               $GSL_INTEG_SINE 
               $GSL_INTEG_GAUSS15 
               $GSL_INTEG_GAUSS21 
               $GSL_INTEG_GAUSS31 
               $GSL_INTEG_GAUSS41 
               $GSL_INTEG_GAUSS51 
               $GSL_INTEG_GAUSS61 
             /;
%EXPORT_TAGS = ( all => [ @EXPORT_OK ] );
1;
