# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.36
#
# Don't modify this file, modify the SWIG interface instead.

package Math::GSL::ODEIV;
use base qw(Exporter);
use base qw(DynaLoader);
package Math::GSL::ODEIVc;
bootstrap Math::GSL::ODEIV;
package Math::GSL::ODEIV;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Math::GSL::ODEIV;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Math::GSL::ODEIV;

*gsl_odeiv_step_alloc = *Math::GSL::ODEIVc::gsl_odeiv_step_alloc;
*gsl_odeiv_step_reset = *Math::GSL::ODEIVc::gsl_odeiv_step_reset;
*gsl_odeiv_step_free = *Math::GSL::ODEIVc::gsl_odeiv_step_free;
*gsl_odeiv_step_name = *Math::GSL::ODEIVc::gsl_odeiv_step_name;
*gsl_odeiv_step_order = *Math::GSL::ODEIVc::gsl_odeiv_step_order;
*gsl_odeiv_step_apply = *Math::GSL::ODEIVc::gsl_odeiv_step_apply;
*gsl_odeiv_control_alloc = *Math::GSL::ODEIVc::gsl_odeiv_control_alloc;
*gsl_odeiv_control_init = *Math::GSL::ODEIVc::gsl_odeiv_control_init;
*gsl_odeiv_control_free = *Math::GSL::ODEIVc::gsl_odeiv_control_free;
*gsl_odeiv_control_hadjust = *Math::GSL::ODEIVc::gsl_odeiv_control_hadjust;
*gsl_odeiv_control_name = *Math::GSL::ODEIVc::gsl_odeiv_control_name;
*gsl_odeiv_control_standard_new = *Math::GSL::ODEIVc::gsl_odeiv_control_standard_new;
*gsl_odeiv_control_y_new = *Math::GSL::ODEIVc::gsl_odeiv_control_y_new;
*gsl_odeiv_control_yp_new = *Math::GSL::ODEIVc::gsl_odeiv_control_yp_new;
*gsl_odeiv_control_scaled_new = *Math::GSL::ODEIVc::gsl_odeiv_control_scaled_new;
*gsl_odeiv_evolve_alloc = *Math::GSL::ODEIVc::gsl_odeiv_evolve_alloc;
*gsl_odeiv_evolve_apply = *Math::GSL::ODEIVc::gsl_odeiv_evolve_apply;
*gsl_odeiv_evolve_reset = *Math::GSL::ODEIVc::gsl_odeiv_evolve_reset;
*gsl_odeiv_evolve_free = *Math::GSL::ODEIVc::gsl_odeiv_evolve_free;

############# Class : Math::GSL::ODEIV::gsl_odeiv_system ##############

package Math::GSL::ODEIV::gsl_odeiv_system;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::ODEIV );
%OWNER = ();
%ITERATORS = ();
*swig_function_get = *Math::GSL::ODEIVc::gsl_odeiv_system_function_get;
*swig_function_set = *Math::GSL::ODEIVc::gsl_odeiv_system_function_set;
*swig_jacobian_get = *Math::GSL::ODEIVc::gsl_odeiv_system_jacobian_get;
*swig_jacobian_set = *Math::GSL::ODEIVc::gsl_odeiv_system_jacobian_set;
*swig_dimension_get = *Math::GSL::ODEIVc::gsl_odeiv_system_dimension_get;
*swig_dimension_set = *Math::GSL::ODEIVc::gsl_odeiv_system_dimension_set;
*swig_params_get = *Math::GSL::ODEIVc::gsl_odeiv_system_params_get;
*swig_params_set = *Math::GSL::ODEIVc::gsl_odeiv_system_params_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::ODEIVc::new_gsl_odeiv_system(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::ODEIVc::delete_gsl_odeiv_system($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::ODEIV::gsl_odeiv_step_type ##############

package Math::GSL::ODEIV::gsl_odeiv_step_type;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::ODEIV );
%OWNER = ();
%ITERATORS = ();
*swig_name_get = *Math::GSL::ODEIVc::gsl_odeiv_step_type_name_get;
*swig_name_set = *Math::GSL::ODEIVc::gsl_odeiv_step_type_name_set;
*swig_can_use_dydt_in_get = *Math::GSL::ODEIVc::gsl_odeiv_step_type_can_use_dydt_in_get;
*swig_can_use_dydt_in_set = *Math::GSL::ODEIVc::gsl_odeiv_step_type_can_use_dydt_in_set;
*swig_gives_exact_dydt_out_get = *Math::GSL::ODEIVc::gsl_odeiv_step_type_gives_exact_dydt_out_get;
*swig_gives_exact_dydt_out_set = *Math::GSL::ODEIVc::gsl_odeiv_step_type_gives_exact_dydt_out_set;
*swig_alloc_get = *Math::GSL::ODEIVc::gsl_odeiv_step_type_alloc_get;
*swig_alloc_set = *Math::GSL::ODEIVc::gsl_odeiv_step_type_alloc_set;
*swig_apply_get = *Math::GSL::ODEIVc::gsl_odeiv_step_type_apply_get;
*swig_apply_set = *Math::GSL::ODEIVc::gsl_odeiv_step_type_apply_set;
*swig_reset_get = *Math::GSL::ODEIVc::gsl_odeiv_step_type_reset_get;
*swig_reset_set = *Math::GSL::ODEIVc::gsl_odeiv_step_type_reset_set;
*swig_order_get = *Math::GSL::ODEIVc::gsl_odeiv_step_type_order_get;
*swig_order_set = *Math::GSL::ODEIVc::gsl_odeiv_step_type_order_set;
*swig_free_get = *Math::GSL::ODEIVc::gsl_odeiv_step_type_free_get;
*swig_free_set = *Math::GSL::ODEIVc::gsl_odeiv_step_type_free_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::ODEIVc::new_gsl_odeiv_step_type(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::ODEIVc::delete_gsl_odeiv_step_type($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::ODEIV::gsl_odeiv_step ##############

package Math::GSL::ODEIV::gsl_odeiv_step;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::ODEIV );
%OWNER = ();
%ITERATORS = ();
*swig_type_get = *Math::GSL::ODEIVc::gsl_odeiv_step_type_get;
*swig_type_set = *Math::GSL::ODEIVc::gsl_odeiv_step_type_set;
*swig_dimension_get = *Math::GSL::ODEIVc::gsl_odeiv_step_dimension_get;
*swig_dimension_set = *Math::GSL::ODEIVc::gsl_odeiv_step_dimension_set;
*swig_state_get = *Math::GSL::ODEIVc::gsl_odeiv_step_state_get;
*swig_state_set = *Math::GSL::ODEIVc::gsl_odeiv_step_state_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::ODEIVc::new_gsl_odeiv_step(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::ODEIVc::delete_gsl_odeiv_step($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::ODEIV::gsl_odeiv_control_type ##############

package Math::GSL::ODEIV::gsl_odeiv_control_type;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::ODEIV );
%OWNER = ();
%ITERATORS = ();
*swig_name_get = *Math::GSL::ODEIVc::gsl_odeiv_control_type_name_get;
*swig_name_set = *Math::GSL::ODEIVc::gsl_odeiv_control_type_name_set;
*swig_alloc_get = *Math::GSL::ODEIVc::gsl_odeiv_control_type_alloc_get;
*swig_alloc_set = *Math::GSL::ODEIVc::gsl_odeiv_control_type_alloc_set;
*swig_init_get = *Math::GSL::ODEIVc::gsl_odeiv_control_type_init_get;
*swig_init_set = *Math::GSL::ODEIVc::gsl_odeiv_control_type_init_set;
*swig_hadjust_get = *Math::GSL::ODEIVc::gsl_odeiv_control_type_hadjust_get;
*swig_hadjust_set = *Math::GSL::ODEIVc::gsl_odeiv_control_type_hadjust_set;
*swig_free_get = *Math::GSL::ODEIVc::gsl_odeiv_control_type_free_get;
*swig_free_set = *Math::GSL::ODEIVc::gsl_odeiv_control_type_free_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::ODEIVc::new_gsl_odeiv_control_type(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::ODEIVc::delete_gsl_odeiv_control_type($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::ODEIV::gsl_odeiv_control ##############

package Math::GSL::ODEIV::gsl_odeiv_control;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::ODEIV );
%OWNER = ();
%ITERATORS = ();
*swig_type_get = *Math::GSL::ODEIVc::gsl_odeiv_control_type_get;
*swig_type_set = *Math::GSL::ODEIVc::gsl_odeiv_control_type_set;
*swig_state_get = *Math::GSL::ODEIVc::gsl_odeiv_control_state_get;
*swig_state_set = *Math::GSL::ODEIVc::gsl_odeiv_control_state_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::ODEIVc::new_gsl_odeiv_control(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::ODEIVc::delete_gsl_odeiv_control($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::ODEIV::gsl_odeiv_evolve ##############

package Math::GSL::ODEIV::gsl_odeiv_evolve;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::ODEIV );
%OWNER = ();
%ITERATORS = ();
*swig_dimension_get = *Math::GSL::ODEIVc::gsl_odeiv_evolve_dimension_get;
*swig_dimension_set = *Math::GSL::ODEIVc::gsl_odeiv_evolve_dimension_set;
*swig_y0_get = *Math::GSL::ODEIVc::gsl_odeiv_evolve_y0_get;
*swig_y0_set = *Math::GSL::ODEIVc::gsl_odeiv_evolve_y0_set;
*swig_yerr_get = *Math::GSL::ODEIVc::gsl_odeiv_evolve_yerr_get;
*swig_yerr_set = *Math::GSL::ODEIVc::gsl_odeiv_evolve_yerr_set;
*swig_dydt_in_get = *Math::GSL::ODEIVc::gsl_odeiv_evolve_dydt_in_get;
*swig_dydt_in_set = *Math::GSL::ODEIVc::gsl_odeiv_evolve_dydt_in_set;
*swig_dydt_out_get = *Math::GSL::ODEIVc::gsl_odeiv_evolve_dydt_out_get;
*swig_dydt_out_set = *Math::GSL::ODEIVc::gsl_odeiv_evolve_dydt_out_set;
*swig_last_step_get = *Math::GSL::ODEIVc::gsl_odeiv_evolve_last_step_get;
*swig_last_step_set = *Math::GSL::ODEIVc::gsl_odeiv_evolve_last_step_set;
*swig_count_get = *Math::GSL::ODEIVc::gsl_odeiv_evolve_count_get;
*swig_count_set = *Math::GSL::ODEIVc::gsl_odeiv_evolve_count_set;
*swig_failed_steps_get = *Math::GSL::ODEIVc::gsl_odeiv_evolve_failed_steps_get;
*swig_failed_steps_set = *Math::GSL::ODEIVc::gsl_odeiv_evolve_failed_steps_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::ODEIVc::new_gsl_odeiv_evolve(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::ODEIVc::delete_gsl_odeiv_evolve($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package Math::GSL::ODEIV;


my %__gsl_odeiv_step_rk2_hash;
tie %__gsl_odeiv_step_rk2_hash,"Math::GSL::ODEIV::gsl_odeiv_step_type", $Math::GSL::ODEIVc::gsl_odeiv_step_rk2;
$gsl_odeiv_step_rk2= \%__gsl_odeiv_step_rk2_hash;
bless $gsl_odeiv_step_rk2, Math::GSL::ODEIV::gsl_odeiv_step_type;

my %__gsl_odeiv_step_rk4_hash;
tie %__gsl_odeiv_step_rk4_hash,"Math::GSL::ODEIV::gsl_odeiv_step_type", $Math::GSL::ODEIVc::gsl_odeiv_step_rk4;
$gsl_odeiv_step_rk4= \%__gsl_odeiv_step_rk4_hash;
bless $gsl_odeiv_step_rk4, Math::GSL::ODEIV::gsl_odeiv_step_type;

my %__gsl_odeiv_step_rkf45_hash;
tie %__gsl_odeiv_step_rkf45_hash,"Math::GSL::ODEIV::gsl_odeiv_step_type", $Math::GSL::ODEIVc::gsl_odeiv_step_rkf45;
$gsl_odeiv_step_rkf45= \%__gsl_odeiv_step_rkf45_hash;
bless $gsl_odeiv_step_rkf45, Math::GSL::ODEIV::gsl_odeiv_step_type;

my %__gsl_odeiv_step_rkck_hash;
tie %__gsl_odeiv_step_rkck_hash,"Math::GSL::ODEIV::gsl_odeiv_step_type", $Math::GSL::ODEIVc::gsl_odeiv_step_rkck;
$gsl_odeiv_step_rkck= \%__gsl_odeiv_step_rkck_hash;
bless $gsl_odeiv_step_rkck, Math::GSL::ODEIV::gsl_odeiv_step_type;

my %__gsl_odeiv_step_rk8pd_hash;
tie %__gsl_odeiv_step_rk8pd_hash,"Math::GSL::ODEIV::gsl_odeiv_step_type", $Math::GSL::ODEIVc::gsl_odeiv_step_rk8pd;
$gsl_odeiv_step_rk8pd= \%__gsl_odeiv_step_rk8pd_hash;
bless $gsl_odeiv_step_rk8pd, Math::GSL::ODEIV::gsl_odeiv_step_type;

my %__gsl_odeiv_step_rk2imp_hash;
tie %__gsl_odeiv_step_rk2imp_hash,"Math::GSL::ODEIV::gsl_odeiv_step_type", $Math::GSL::ODEIVc::gsl_odeiv_step_rk2imp;
$gsl_odeiv_step_rk2imp= \%__gsl_odeiv_step_rk2imp_hash;
bless $gsl_odeiv_step_rk2imp, Math::GSL::ODEIV::gsl_odeiv_step_type;

my %__gsl_odeiv_step_rk2simp_hash;
tie %__gsl_odeiv_step_rk2simp_hash,"Math::GSL::ODEIV::gsl_odeiv_step_type", $Math::GSL::ODEIVc::gsl_odeiv_step_rk2simp;
$gsl_odeiv_step_rk2simp= \%__gsl_odeiv_step_rk2simp_hash;
bless $gsl_odeiv_step_rk2simp, Math::GSL::ODEIV::gsl_odeiv_step_type;

my %__gsl_odeiv_step_rk4imp_hash;
tie %__gsl_odeiv_step_rk4imp_hash,"Math::GSL::ODEIV::gsl_odeiv_step_type", $Math::GSL::ODEIVc::gsl_odeiv_step_rk4imp;
$gsl_odeiv_step_rk4imp= \%__gsl_odeiv_step_rk4imp_hash;
bless $gsl_odeiv_step_rk4imp, Math::GSL::ODEIV::gsl_odeiv_step_type;

my %__gsl_odeiv_step_bsimp_hash;
tie %__gsl_odeiv_step_bsimp_hash,"Math::GSL::ODEIV::gsl_odeiv_step_type", $Math::GSL::ODEIVc::gsl_odeiv_step_bsimp;
$gsl_odeiv_step_bsimp= \%__gsl_odeiv_step_bsimp_hash;
bless $gsl_odeiv_step_bsimp, Math::GSL::ODEIV::gsl_odeiv_step_type;

my %__gsl_odeiv_step_gear1_hash;
tie %__gsl_odeiv_step_gear1_hash,"Math::GSL::ODEIV::gsl_odeiv_step_type", $Math::GSL::ODEIVc::gsl_odeiv_step_gear1;
$gsl_odeiv_step_gear1= \%__gsl_odeiv_step_gear1_hash;
bless $gsl_odeiv_step_gear1, Math::GSL::ODEIV::gsl_odeiv_step_type;

my %__gsl_odeiv_step_gear2_hash;
tie %__gsl_odeiv_step_gear2_hash,"Math::GSL::ODEIV::gsl_odeiv_step_type", $Math::GSL::ODEIVc::gsl_odeiv_step_gear2;
$gsl_odeiv_step_gear2= \%__gsl_odeiv_step_gear2_hash;
bless $gsl_odeiv_step_gear2, Math::GSL::ODEIV::gsl_odeiv_step_type;
*GSL_ODEIV_HADJ_INC = *Math::GSL::ODEIVc::GSL_ODEIV_HADJ_INC;
*GSL_ODEIV_HADJ_NIL = *Math::GSL::ODEIVc::GSL_ODEIV_HADJ_NIL;
*GSL_ODEIV_HADJ_DEC = *Math::GSL::ODEIVc::GSL_ODEIV_HADJ_DEC;

@EXPORT_OK = qw/
               gsl_odeiv_step_alloc 
               gsl_odeiv_step_reset 
               gsl_odeiv_step_free 
               gsl_odeiv_step_name 
               gsl_odeiv_step_order 
               gsl_odeiv_step_apply 
               gsl_odeiv_control_alloc 
               gsl_odeiv_control_init 
               gsl_odeiv_control_free 
               gsl_odeiv_control_hadjust 
               gsl_odeiv_control_name 
               gsl_odeiv_control_standard_new 
               gsl_odeiv_control_y_new 
               gsl_odeiv_control_yp_new 
               gsl_odeiv_control_scaled_new 
               gsl_odeiv_evolve_alloc 
               gsl_odeiv_evolve_apply 
               gsl_odeiv_evolve_reset 
               gsl_odeiv_evolve_free 
               $gsl_odeiv_step_rk2
               $gsl_odeiv_step_rk4
               $gsl_odeiv_step_rkf45
               $gsl_odeiv_step_rkck
               $gsl_odeiv_step_rk8pd
               $gsl_odeiv_step_rk2imp
               $gsl_odeiv_step_rk2simp
               $gsl_odeiv_step_rk4imp
               $gsl_odeiv_step_bsimp
               $gsl_odeiv_step_gear1
               $gsl_odeiv_step_gear2
               GSL_ODEIV_HADJ_INC 
               GSL_ODEIV_HADJ_NIL 
               GSL_ODEIV_HADJ_DEC 
             /;
%EXPORT_TAGS = ( all => [ @EXPORT_OK ] );
1;
