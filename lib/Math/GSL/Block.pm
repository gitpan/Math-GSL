# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.36
#
# Don't modify this file, modify the SWIG interface instead.

package Math::GSL::Block;
use base qw(Exporter);
use base qw(DynaLoader);
package Math::GSL::Blockc;
bootstrap Math::GSL::Block;
package Math::GSL::Block;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Math::GSL::Block;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Math::GSL::Block;

*gsl_block_char_alloc = *Math::GSL::Blockc::gsl_block_char_alloc;
*gsl_block_char_calloc = *Math::GSL::Blockc::gsl_block_char_calloc;
*gsl_block_char_free = *Math::GSL::Blockc::gsl_block_char_free;
*gsl_block_char_fread = *Math::GSL::Blockc::gsl_block_char_fread;
*gsl_block_char_fwrite = *Math::GSL::Blockc::gsl_block_char_fwrite;
*gsl_block_char_fscanf = *Math::GSL::Blockc::gsl_block_char_fscanf;
*gsl_block_char_fprintf = *Math::GSL::Blockc::gsl_block_char_fprintf;
*gsl_block_char_raw_fread = *Math::GSL::Blockc::gsl_block_char_raw_fread;
*gsl_block_char_raw_fwrite = *Math::GSL::Blockc::gsl_block_char_raw_fwrite;
*gsl_block_char_raw_fscanf = *Math::GSL::Blockc::gsl_block_char_raw_fscanf;
*gsl_block_char_raw_fprintf = *Math::GSL::Blockc::gsl_block_char_raw_fprintf;
*gsl_block_char_size = *Math::GSL::Blockc::gsl_block_char_size;
*gsl_block_char_data = *Math::GSL::Blockc::gsl_block_char_data;
*gsl_block_complex_alloc = *Math::GSL::Blockc::gsl_block_complex_alloc;
*gsl_block_complex_calloc = *Math::GSL::Blockc::gsl_block_complex_calloc;
*gsl_block_complex_free = *Math::GSL::Blockc::gsl_block_complex_free;
*gsl_block_complex_fread = *Math::GSL::Blockc::gsl_block_complex_fread;
*gsl_block_complex_fwrite = *Math::GSL::Blockc::gsl_block_complex_fwrite;
*gsl_block_complex_fscanf = *Math::GSL::Blockc::gsl_block_complex_fscanf;
*gsl_block_complex_fprintf = *Math::GSL::Blockc::gsl_block_complex_fprintf;
*gsl_block_complex_raw_fread = *Math::GSL::Blockc::gsl_block_complex_raw_fread;
*gsl_block_complex_raw_fwrite = *Math::GSL::Blockc::gsl_block_complex_raw_fwrite;
*gsl_block_complex_raw_fscanf = *Math::GSL::Blockc::gsl_block_complex_raw_fscanf;
*gsl_block_complex_raw_fprintf = *Math::GSL::Blockc::gsl_block_complex_raw_fprintf;
*gsl_block_complex_size = *Math::GSL::Blockc::gsl_block_complex_size;
*gsl_block_complex_data = *Math::GSL::Blockc::gsl_block_complex_data;
*gsl_block_complex_float_alloc = *Math::GSL::Blockc::gsl_block_complex_float_alloc;
*gsl_block_complex_float_calloc = *Math::GSL::Blockc::gsl_block_complex_float_calloc;
*gsl_block_complex_float_free = *Math::GSL::Blockc::gsl_block_complex_float_free;
*gsl_block_complex_float_fread = *Math::GSL::Blockc::gsl_block_complex_float_fread;
*gsl_block_complex_float_fwrite = *Math::GSL::Blockc::gsl_block_complex_float_fwrite;
*gsl_block_complex_float_fscanf = *Math::GSL::Blockc::gsl_block_complex_float_fscanf;
*gsl_block_complex_float_fprintf = *Math::GSL::Blockc::gsl_block_complex_float_fprintf;
*gsl_block_complex_float_raw_fread = *Math::GSL::Blockc::gsl_block_complex_float_raw_fread;
*gsl_block_complex_float_raw_fwrite = *Math::GSL::Blockc::gsl_block_complex_float_raw_fwrite;
*gsl_block_complex_float_raw_fscanf = *Math::GSL::Blockc::gsl_block_complex_float_raw_fscanf;
*gsl_block_complex_float_raw_fprintf = *Math::GSL::Blockc::gsl_block_complex_float_raw_fprintf;
*gsl_block_complex_float_size = *Math::GSL::Blockc::gsl_block_complex_float_size;
*gsl_block_complex_float_data = *Math::GSL::Blockc::gsl_block_complex_float_data;
*gsl_block_complex_long_double_alloc = *Math::GSL::Blockc::gsl_block_complex_long_double_alloc;
*gsl_block_complex_long_double_calloc = *Math::GSL::Blockc::gsl_block_complex_long_double_calloc;
*gsl_block_complex_long_double_free = *Math::GSL::Blockc::gsl_block_complex_long_double_free;
*gsl_block_complex_long_double_fread = *Math::GSL::Blockc::gsl_block_complex_long_double_fread;
*gsl_block_complex_long_double_fwrite = *Math::GSL::Blockc::gsl_block_complex_long_double_fwrite;
*gsl_block_complex_long_double_fscanf = *Math::GSL::Blockc::gsl_block_complex_long_double_fscanf;
*gsl_block_complex_long_double_fprintf = *Math::GSL::Blockc::gsl_block_complex_long_double_fprintf;
*gsl_block_complex_long_double_raw_fread = *Math::GSL::Blockc::gsl_block_complex_long_double_raw_fread;
*gsl_block_complex_long_double_raw_fwrite = *Math::GSL::Blockc::gsl_block_complex_long_double_raw_fwrite;
*gsl_block_complex_long_double_raw_fscanf = *Math::GSL::Blockc::gsl_block_complex_long_double_raw_fscanf;
*gsl_block_complex_long_double_raw_fprintf = *Math::GSL::Blockc::gsl_block_complex_long_double_raw_fprintf;
*gsl_block_complex_long_double_size = *Math::GSL::Blockc::gsl_block_complex_long_double_size;
*gsl_block_complex_long_double_data = *Math::GSL::Blockc::gsl_block_complex_long_double_data;
*gsl_block_alloc = *Math::GSL::Blockc::gsl_block_alloc;
*gsl_block_calloc = *Math::GSL::Blockc::gsl_block_calloc;
*gsl_block_free = *Math::GSL::Blockc::gsl_block_free;
*gsl_block_fread = *Math::GSL::Blockc::gsl_block_fread;
*gsl_block_fwrite = *Math::GSL::Blockc::gsl_block_fwrite;
*gsl_block_fscanf = *Math::GSL::Blockc::gsl_block_fscanf;
*gsl_block_fprintf = *Math::GSL::Blockc::gsl_block_fprintf;
*gsl_block_raw_fread = *Math::GSL::Blockc::gsl_block_raw_fread;
*gsl_block_raw_fwrite = *Math::GSL::Blockc::gsl_block_raw_fwrite;
*gsl_block_raw_fscanf = *Math::GSL::Blockc::gsl_block_raw_fscanf;
*gsl_block_raw_fprintf = *Math::GSL::Blockc::gsl_block_raw_fprintf;
*gsl_block_size = *Math::GSL::Blockc::gsl_block_size;
*gsl_block_data = *Math::GSL::Blockc::gsl_block_data;
*gsl_block_float_alloc = *Math::GSL::Blockc::gsl_block_float_alloc;
*gsl_block_float_calloc = *Math::GSL::Blockc::gsl_block_float_calloc;
*gsl_block_float_free = *Math::GSL::Blockc::gsl_block_float_free;
*gsl_block_float_fread = *Math::GSL::Blockc::gsl_block_float_fread;
*gsl_block_float_fwrite = *Math::GSL::Blockc::gsl_block_float_fwrite;
*gsl_block_float_fscanf = *Math::GSL::Blockc::gsl_block_float_fscanf;
*gsl_block_float_fprintf = *Math::GSL::Blockc::gsl_block_float_fprintf;
*gsl_block_float_raw_fread = *Math::GSL::Blockc::gsl_block_float_raw_fread;
*gsl_block_float_raw_fwrite = *Math::GSL::Blockc::gsl_block_float_raw_fwrite;
*gsl_block_float_raw_fscanf = *Math::GSL::Blockc::gsl_block_float_raw_fscanf;
*gsl_block_float_raw_fprintf = *Math::GSL::Blockc::gsl_block_float_raw_fprintf;
*gsl_block_float_size = *Math::GSL::Blockc::gsl_block_float_size;
*gsl_block_float_data = *Math::GSL::Blockc::gsl_block_float_data;
*gsl_block_int_alloc = *Math::GSL::Blockc::gsl_block_int_alloc;
*gsl_block_int_calloc = *Math::GSL::Blockc::gsl_block_int_calloc;
*gsl_block_int_free = *Math::GSL::Blockc::gsl_block_int_free;
*gsl_block_int_fread = *Math::GSL::Blockc::gsl_block_int_fread;
*gsl_block_int_fwrite = *Math::GSL::Blockc::gsl_block_int_fwrite;
*gsl_block_int_fscanf = *Math::GSL::Blockc::gsl_block_int_fscanf;
*gsl_block_int_fprintf = *Math::GSL::Blockc::gsl_block_int_fprintf;
*gsl_block_int_raw_fread = *Math::GSL::Blockc::gsl_block_int_raw_fread;
*gsl_block_int_raw_fwrite = *Math::GSL::Blockc::gsl_block_int_raw_fwrite;
*gsl_block_int_raw_fscanf = *Math::GSL::Blockc::gsl_block_int_raw_fscanf;
*gsl_block_int_raw_fprintf = *Math::GSL::Blockc::gsl_block_int_raw_fprintf;
*gsl_block_int_size = *Math::GSL::Blockc::gsl_block_int_size;
*gsl_block_int_data = *Math::GSL::Blockc::gsl_block_int_data;
*gsl_block_long_alloc = *Math::GSL::Blockc::gsl_block_long_alloc;
*gsl_block_long_calloc = *Math::GSL::Blockc::gsl_block_long_calloc;
*gsl_block_long_free = *Math::GSL::Blockc::gsl_block_long_free;
*gsl_block_long_fread = *Math::GSL::Blockc::gsl_block_long_fread;
*gsl_block_long_fwrite = *Math::GSL::Blockc::gsl_block_long_fwrite;
*gsl_block_long_fscanf = *Math::GSL::Blockc::gsl_block_long_fscanf;
*gsl_block_long_fprintf = *Math::GSL::Blockc::gsl_block_long_fprintf;
*gsl_block_long_raw_fread = *Math::GSL::Blockc::gsl_block_long_raw_fread;
*gsl_block_long_raw_fwrite = *Math::GSL::Blockc::gsl_block_long_raw_fwrite;
*gsl_block_long_raw_fscanf = *Math::GSL::Blockc::gsl_block_long_raw_fscanf;
*gsl_block_long_raw_fprintf = *Math::GSL::Blockc::gsl_block_long_raw_fprintf;
*gsl_block_long_size = *Math::GSL::Blockc::gsl_block_long_size;
*gsl_block_long_data = *Math::GSL::Blockc::gsl_block_long_data;
*gsl_block_long_double_alloc = *Math::GSL::Blockc::gsl_block_long_double_alloc;
*gsl_block_long_double_calloc = *Math::GSL::Blockc::gsl_block_long_double_calloc;
*gsl_block_long_double_free = *Math::GSL::Blockc::gsl_block_long_double_free;
*gsl_block_long_double_fread = *Math::GSL::Blockc::gsl_block_long_double_fread;
*gsl_block_long_double_fwrite = *Math::GSL::Blockc::gsl_block_long_double_fwrite;
*gsl_block_long_double_fscanf = *Math::GSL::Blockc::gsl_block_long_double_fscanf;
*gsl_block_long_double_fprintf = *Math::GSL::Blockc::gsl_block_long_double_fprintf;
*gsl_block_long_double_raw_fread = *Math::GSL::Blockc::gsl_block_long_double_raw_fread;
*gsl_block_long_double_raw_fwrite = *Math::GSL::Blockc::gsl_block_long_double_raw_fwrite;
*gsl_block_long_double_raw_fscanf = *Math::GSL::Blockc::gsl_block_long_double_raw_fscanf;
*gsl_block_long_double_raw_fprintf = *Math::GSL::Blockc::gsl_block_long_double_raw_fprintf;
*gsl_block_long_double_size = *Math::GSL::Blockc::gsl_block_long_double_size;
*gsl_block_long_double_data = *Math::GSL::Blockc::gsl_block_long_double_data;
*gsl_block_short_alloc = *Math::GSL::Blockc::gsl_block_short_alloc;
*gsl_block_short_calloc = *Math::GSL::Blockc::gsl_block_short_calloc;
*gsl_block_short_free = *Math::GSL::Blockc::gsl_block_short_free;
*gsl_block_short_fread = *Math::GSL::Blockc::gsl_block_short_fread;
*gsl_block_short_fwrite = *Math::GSL::Blockc::gsl_block_short_fwrite;
*gsl_block_short_fscanf = *Math::GSL::Blockc::gsl_block_short_fscanf;
*gsl_block_short_fprintf = *Math::GSL::Blockc::gsl_block_short_fprintf;
*gsl_block_short_raw_fread = *Math::GSL::Blockc::gsl_block_short_raw_fread;
*gsl_block_short_raw_fwrite = *Math::GSL::Blockc::gsl_block_short_raw_fwrite;
*gsl_block_short_raw_fscanf = *Math::GSL::Blockc::gsl_block_short_raw_fscanf;
*gsl_block_short_raw_fprintf = *Math::GSL::Blockc::gsl_block_short_raw_fprintf;
*gsl_block_short_size = *Math::GSL::Blockc::gsl_block_short_size;
*gsl_block_short_data = *Math::GSL::Blockc::gsl_block_short_data;
*gsl_block_uchar_alloc = *Math::GSL::Blockc::gsl_block_uchar_alloc;
*gsl_block_uchar_calloc = *Math::GSL::Blockc::gsl_block_uchar_calloc;
*gsl_block_uchar_free = *Math::GSL::Blockc::gsl_block_uchar_free;
*gsl_block_uchar_fread = *Math::GSL::Blockc::gsl_block_uchar_fread;
*gsl_block_uchar_fwrite = *Math::GSL::Blockc::gsl_block_uchar_fwrite;
*gsl_block_uchar_fscanf = *Math::GSL::Blockc::gsl_block_uchar_fscanf;
*gsl_block_uchar_fprintf = *Math::GSL::Blockc::gsl_block_uchar_fprintf;
*gsl_block_uchar_raw_fread = *Math::GSL::Blockc::gsl_block_uchar_raw_fread;
*gsl_block_uchar_raw_fwrite = *Math::GSL::Blockc::gsl_block_uchar_raw_fwrite;
*gsl_block_uchar_raw_fscanf = *Math::GSL::Blockc::gsl_block_uchar_raw_fscanf;
*gsl_block_uchar_raw_fprintf = *Math::GSL::Blockc::gsl_block_uchar_raw_fprintf;
*gsl_block_uchar_size = *Math::GSL::Blockc::gsl_block_uchar_size;
*gsl_block_uchar_data = *Math::GSL::Blockc::gsl_block_uchar_data;
*gsl_block_uint_alloc = *Math::GSL::Blockc::gsl_block_uint_alloc;
*gsl_block_uint_calloc = *Math::GSL::Blockc::gsl_block_uint_calloc;
*gsl_block_uint_free = *Math::GSL::Blockc::gsl_block_uint_free;
*gsl_block_uint_fread = *Math::GSL::Blockc::gsl_block_uint_fread;
*gsl_block_uint_fwrite = *Math::GSL::Blockc::gsl_block_uint_fwrite;
*gsl_block_uint_fscanf = *Math::GSL::Blockc::gsl_block_uint_fscanf;
*gsl_block_uint_fprintf = *Math::GSL::Blockc::gsl_block_uint_fprintf;
*gsl_block_uint_raw_fread = *Math::GSL::Blockc::gsl_block_uint_raw_fread;
*gsl_block_uint_raw_fwrite = *Math::GSL::Blockc::gsl_block_uint_raw_fwrite;
*gsl_block_uint_raw_fscanf = *Math::GSL::Blockc::gsl_block_uint_raw_fscanf;
*gsl_block_uint_raw_fprintf = *Math::GSL::Blockc::gsl_block_uint_raw_fprintf;
*gsl_block_uint_size = *Math::GSL::Blockc::gsl_block_uint_size;
*gsl_block_uint_data = *Math::GSL::Blockc::gsl_block_uint_data;
*gsl_block_ulong_alloc = *Math::GSL::Blockc::gsl_block_ulong_alloc;
*gsl_block_ulong_calloc = *Math::GSL::Blockc::gsl_block_ulong_calloc;
*gsl_block_ulong_free = *Math::GSL::Blockc::gsl_block_ulong_free;
*gsl_block_ulong_fread = *Math::GSL::Blockc::gsl_block_ulong_fread;
*gsl_block_ulong_fwrite = *Math::GSL::Blockc::gsl_block_ulong_fwrite;
*gsl_block_ulong_fscanf = *Math::GSL::Blockc::gsl_block_ulong_fscanf;
*gsl_block_ulong_fprintf = *Math::GSL::Blockc::gsl_block_ulong_fprintf;
*gsl_block_ulong_raw_fread = *Math::GSL::Blockc::gsl_block_ulong_raw_fread;
*gsl_block_ulong_raw_fwrite = *Math::GSL::Blockc::gsl_block_ulong_raw_fwrite;
*gsl_block_ulong_raw_fscanf = *Math::GSL::Blockc::gsl_block_ulong_raw_fscanf;
*gsl_block_ulong_raw_fprintf = *Math::GSL::Blockc::gsl_block_ulong_raw_fprintf;
*gsl_block_ulong_size = *Math::GSL::Blockc::gsl_block_ulong_size;
*gsl_block_ulong_data = *Math::GSL::Blockc::gsl_block_ulong_data;
*gsl_block_ushort_alloc = *Math::GSL::Blockc::gsl_block_ushort_alloc;
*gsl_block_ushort_calloc = *Math::GSL::Blockc::gsl_block_ushort_calloc;
*gsl_block_ushort_free = *Math::GSL::Blockc::gsl_block_ushort_free;
*gsl_block_ushort_fread = *Math::GSL::Blockc::gsl_block_ushort_fread;
*gsl_block_ushort_fwrite = *Math::GSL::Blockc::gsl_block_ushort_fwrite;
*gsl_block_ushort_fscanf = *Math::GSL::Blockc::gsl_block_ushort_fscanf;
*gsl_block_ushort_fprintf = *Math::GSL::Blockc::gsl_block_ushort_fprintf;
*gsl_block_ushort_raw_fread = *Math::GSL::Blockc::gsl_block_ushort_raw_fread;
*gsl_block_ushort_raw_fwrite = *Math::GSL::Blockc::gsl_block_ushort_raw_fwrite;
*gsl_block_ushort_raw_fscanf = *Math::GSL::Blockc::gsl_block_ushort_raw_fscanf;
*gsl_block_ushort_raw_fprintf = *Math::GSL::Blockc::gsl_block_ushort_raw_fprintf;
*gsl_block_ushort_size = *Math::GSL::Blockc::gsl_block_ushort_size;
*gsl_block_ushort_data = *Math::GSL::Blockc::gsl_block_ushort_data;

############# Class : Math::GSL::Block::gsl_block_char_struct ##############

package Math::GSL::Block::gsl_block_char_struct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::Block );
%OWNER = ();
%ITERATORS = ();
*swig_size_get = *Math::GSL::Blockc::gsl_block_char_struct_size_get;
*swig_size_set = *Math::GSL::Blockc::gsl_block_char_struct_size_set;
*swig_data_get = *Math::GSL::Blockc::gsl_block_char_struct_data_get;
*swig_data_set = *Math::GSL::Blockc::gsl_block_char_struct_data_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::Blockc::new_gsl_block_char_struct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::Blockc::delete_gsl_block_char_struct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::Block::gsl_block_complex_struct ##############

package Math::GSL::Block::gsl_block_complex_struct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::Block );
%OWNER = ();
%ITERATORS = ();
*swig_size_get = *Math::GSL::Blockc::gsl_block_complex_struct_size_get;
*swig_size_set = *Math::GSL::Blockc::gsl_block_complex_struct_size_set;
*swig_data_get = *Math::GSL::Blockc::gsl_block_complex_struct_data_get;
*swig_data_set = *Math::GSL::Blockc::gsl_block_complex_struct_data_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::Blockc::new_gsl_block_complex_struct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::Blockc::delete_gsl_block_complex_struct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::Block::gsl_block_complex_float_struct ##############

package Math::GSL::Block::gsl_block_complex_float_struct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::Block );
%OWNER = ();
%ITERATORS = ();
*swig_size_get = *Math::GSL::Blockc::gsl_block_complex_float_struct_size_get;
*swig_size_set = *Math::GSL::Blockc::gsl_block_complex_float_struct_size_set;
*swig_data_get = *Math::GSL::Blockc::gsl_block_complex_float_struct_data_get;
*swig_data_set = *Math::GSL::Blockc::gsl_block_complex_float_struct_data_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::Blockc::new_gsl_block_complex_float_struct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::Blockc::delete_gsl_block_complex_float_struct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::Block::gsl_block_complex_long_double_struct ##############

package Math::GSL::Block::gsl_block_complex_long_double_struct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::Block );
%OWNER = ();
%ITERATORS = ();
*swig_size_get = *Math::GSL::Blockc::gsl_block_complex_long_double_struct_size_get;
*swig_size_set = *Math::GSL::Blockc::gsl_block_complex_long_double_struct_size_set;
*swig_data_get = *Math::GSL::Blockc::gsl_block_complex_long_double_struct_data_get;
*swig_data_set = *Math::GSL::Blockc::gsl_block_complex_long_double_struct_data_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::Blockc::new_gsl_block_complex_long_double_struct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::Blockc::delete_gsl_block_complex_long_double_struct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::Block::gsl_block_struct ##############

package Math::GSL::Block::gsl_block_struct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::Block );
%OWNER = ();
%ITERATORS = ();
*swig_size_get = *Math::GSL::Blockc::gsl_block_struct_size_get;
*swig_size_set = *Math::GSL::Blockc::gsl_block_struct_size_set;
*swig_data_get = *Math::GSL::Blockc::gsl_block_struct_data_get;
*swig_data_set = *Math::GSL::Blockc::gsl_block_struct_data_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::Blockc::new_gsl_block_struct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::Blockc::delete_gsl_block_struct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::Block::gsl_block_float_struct ##############

package Math::GSL::Block::gsl_block_float_struct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::Block );
%OWNER = ();
%ITERATORS = ();
*swig_size_get = *Math::GSL::Blockc::gsl_block_float_struct_size_get;
*swig_size_set = *Math::GSL::Blockc::gsl_block_float_struct_size_set;
*swig_data_get = *Math::GSL::Blockc::gsl_block_float_struct_data_get;
*swig_data_set = *Math::GSL::Blockc::gsl_block_float_struct_data_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::Blockc::new_gsl_block_float_struct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::Blockc::delete_gsl_block_float_struct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::Block::gsl_block_int_struct ##############

package Math::GSL::Block::gsl_block_int_struct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::Block );
%OWNER = ();
%ITERATORS = ();
*swig_size_get = *Math::GSL::Blockc::gsl_block_int_struct_size_get;
*swig_size_set = *Math::GSL::Blockc::gsl_block_int_struct_size_set;
*swig_data_get = *Math::GSL::Blockc::gsl_block_int_struct_data_get;
*swig_data_set = *Math::GSL::Blockc::gsl_block_int_struct_data_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::Blockc::new_gsl_block_int_struct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::Blockc::delete_gsl_block_int_struct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::Block::gsl_block_long_struct ##############

package Math::GSL::Block::gsl_block_long_struct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::Block );
%OWNER = ();
%ITERATORS = ();
*swig_size_get = *Math::GSL::Blockc::gsl_block_long_struct_size_get;
*swig_size_set = *Math::GSL::Blockc::gsl_block_long_struct_size_set;
*swig_data_get = *Math::GSL::Blockc::gsl_block_long_struct_data_get;
*swig_data_set = *Math::GSL::Blockc::gsl_block_long_struct_data_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::Blockc::new_gsl_block_long_struct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::Blockc::delete_gsl_block_long_struct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::Block::gsl_block_long_double_struct ##############

package Math::GSL::Block::gsl_block_long_double_struct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::Block );
%OWNER = ();
%ITERATORS = ();
*swig_size_get = *Math::GSL::Blockc::gsl_block_long_double_struct_size_get;
*swig_size_set = *Math::GSL::Blockc::gsl_block_long_double_struct_size_set;
*swig_data_get = *Math::GSL::Blockc::gsl_block_long_double_struct_data_get;
*swig_data_set = *Math::GSL::Blockc::gsl_block_long_double_struct_data_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::Blockc::new_gsl_block_long_double_struct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::Blockc::delete_gsl_block_long_double_struct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::Block::gsl_block_short_struct ##############

package Math::GSL::Block::gsl_block_short_struct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::Block );
%OWNER = ();
%ITERATORS = ();
*swig_size_get = *Math::GSL::Blockc::gsl_block_short_struct_size_get;
*swig_size_set = *Math::GSL::Blockc::gsl_block_short_struct_size_set;
*swig_data_get = *Math::GSL::Blockc::gsl_block_short_struct_data_get;
*swig_data_set = *Math::GSL::Blockc::gsl_block_short_struct_data_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::Blockc::new_gsl_block_short_struct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::Blockc::delete_gsl_block_short_struct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::Block::gsl_block_uchar_struct ##############

package Math::GSL::Block::gsl_block_uchar_struct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::Block );
%OWNER = ();
%ITERATORS = ();
*swig_size_get = *Math::GSL::Blockc::gsl_block_uchar_struct_size_get;
*swig_size_set = *Math::GSL::Blockc::gsl_block_uchar_struct_size_set;
*swig_data_get = *Math::GSL::Blockc::gsl_block_uchar_struct_data_get;
*swig_data_set = *Math::GSL::Blockc::gsl_block_uchar_struct_data_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::Blockc::new_gsl_block_uchar_struct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::Blockc::delete_gsl_block_uchar_struct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::Block::gsl_block_uint_struct ##############

package Math::GSL::Block::gsl_block_uint_struct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::Block );
%OWNER = ();
%ITERATORS = ();
*swig_size_get = *Math::GSL::Blockc::gsl_block_uint_struct_size_get;
*swig_size_set = *Math::GSL::Blockc::gsl_block_uint_struct_size_set;
*swig_data_get = *Math::GSL::Blockc::gsl_block_uint_struct_data_get;
*swig_data_set = *Math::GSL::Blockc::gsl_block_uint_struct_data_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::Blockc::new_gsl_block_uint_struct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::Blockc::delete_gsl_block_uint_struct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::Block::gsl_block_ulong_struct ##############

package Math::GSL::Block::gsl_block_ulong_struct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::Block );
%OWNER = ();
%ITERATORS = ();
*swig_size_get = *Math::GSL::Blockc::gsl_block_ulong_struct_size_get;
*swig_size_set = *Math::GSL::Blockc::gsl_block_ulong_struct_size_set;
*swig_data_get = *Math::GSL::Blockc::gsl_block_ulong_struct_data_get;
*swig_data_set = *Math::GSL::Blockc::gsl_block_ulong_struct_data_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::Blockc::new_gsl_block_ulong_struct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::Blockc::delete_gsl_block_ulong_struct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::Block::gsl_block_ushort_struct ##############

package Math::GSL::Block::gsl_block_ushort_struct;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::Block );
%OWNER = ();
%ITERATORS = ();
*swig_size_get = *Math::GSL::Blockc::gsl_block_ushort_struct_size_get;
*swig_size_set = *Math::GSL::Blockc::gsl_block_ushort_struct_size_set;
*swig_data_get = *Math::GSL::Blockc::gsl_block_ushort_struct_data_get;
*swig_data_set = *Math::GSL::Blockc::gsl_block_ushort_struct_data_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::Blockc::new_gsl_block_ushort_struct(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::Blockc::delete_gsl_block_ushort_struct($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package Math::GSL::Block;



@EXPORT_OK = qw/gsl_block_alloc gsl_block_calloc gsl_block_free 
                gsl_block_fread gsl_block_fwrite gsl_block_fscanf 
                gsl_block_fprintf gsl_block_raw_fread gsl_block_raw_fwrite 
                gsl_block_raw_fscanf gsl_block_raw_fprintf gsl_block_size 
                gsl_block_data 
            /;

%EXPORT_TAGS = ( all => [ @EXPORT_OK ] );


1;
