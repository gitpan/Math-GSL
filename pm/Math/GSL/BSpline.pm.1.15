# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.4
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package Math::GSL::BSpline;
use base qw(Exporter);
use base qw(DynaLoader);
package Math::GSL::BSplinec;
bootstrap Math::GSL::BSpline;
package Math::GSL::BSpline;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Math::GSL::BSpline;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Math::GSL::BSpline;

*gsl_bspline_alloc = *Math::GSL::BSplinec::gsl_bspline_alloc;
*gsl_bspline_free = *Math::GSL::BSplinec::gsl_bspline_free;
*gsl_bspline_ncoeffs = *Math::GSL::BSplinec::gsl_bspline_ncoeffs;
*gsl_bspline_order = *Math::GSL::BSplinec::gsl_bspline_order;
*gsl_bspline_nbreak = *Math::GSL::BSplinec::gsl_bspline_nbreak;
*gsl_bspline_breakpoint = *Math::GSL::BSplinec::gsl_bspline_breakpoint;
*gsl_bspline_greville_abscissa = *Math::GSL::BSplinec::gsl_bspline_greville_abscissa;
*gsl_bspline_knots = *Math::GSL::BSplinec::gsl_bspline_knots;
*gsl_bspline_knots_uniform = *Math::GSL::BSplinec::gsl_bspline_knots_uniform;
*gsl_bspline_eval = *Math::GSL::BSplinec::gsl_bspline_eval;
*gsl_bspline_eval_nonzero = *Math::GSL::BSplinec::gsl_bspline_eval_nonzero;
*gsl_bspline_deriv_alloc = *Math::GSL::BSplinec::gsl_bspline_deriv_alloc;
*gsl_bspline_deriv_free = *Math::GSL::BSplinec::gsl_bspline_deriv_free;
*gsl_bspline_deriv_eval = *Math::GSL::BSplinec::gsl_bspline_deriv_eval;
*gsl_bspline_deriv_eval_nonzero = *Math::GSL::BSplinec::gsl_bspline_deriv_eval_nonzero;

############# Class : Math::GSL::BSpline::gsl_bspline_workspace ##############

package Math::GSL::BSpline::gsl_bspline_workspace;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::BSpline );
%OWNER = ();
%ITERATORS = ();
*swig_k_get = *Math::GSL::BSplinec::gsl_bspline_workspace_k_get;
*swig_k_set = *Math::GSL::BSplinec::gsl_bspline_workspace_k_set;
*swig_km1_get = *Math::GSL::BSplinec::gsl_bspline_workspace_km1_get;
*swig_km1_set = *Math::GSL::BSplinec::gsl_bspline_workspace_km1_set;
*swig_l_get = *Math::GSL::BSplinec::gsl_bspline_workspace_l_get;
*swig_l_set = *Math::GSL::BSplinec::gsl_bspline_workspace_l_set;
*swig_nbreak_get = *Math::GSL::BSplinec::gsl_bspline_workspace_nbreak_get;
*swig_nbreak_set = *Math::GSL::BSplinec::gsl_bspline_workspace_nbreak_set;
*swig_n_get = *Math::GSL::BSplinec::gsl_bspline_workspace_n_get;
*swig_n_set = *Math::GSL::BSplinec::gsl_bspline_workspace_n_set;
*swig_knots_get = *Math::GSL::BSplinec::gsl_bspline_workspace_knots_get;
*swig_knots_set = *Math::GSL::BSplinec::gsl_bspline_workspace_knots_set;
*swig_deltal_get = *Math::GSL::BSplinec::gsl_bspline_workspace_deltal_get;
*swig_deltal_set = *Math::GSL::BSplinec::gsl_bspline_workspace_deltal_set;
*swig_deltar_get = *Math::GSL::BSplinec::gsl_bspline_workspace_deltar_get;
*swig_deltar_set = *Math::GSL::BSplinec::gsl_bspline_workspace_deltar_set;
*swig_B_get = *Math::GSL::BSplinec::gsl_bspline_workspace_B_get;
*swig_B_set = *Math::GSL::BSplinec::gsl_bspline_workspace_B_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::BSplinec::new_gsl_bspline_workspace(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::BSplinec::delete_gsl_bspline_workspace($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::BSpline::gsl_bspline_deriv_workspace ##############

package Math::GSL::BSpline::gsl_bspline_deriv_workspace;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::BSpline );
%OWNER = ();
%ITERATORS = ();
*swig_k_get = *Math::GSL::BSplinec::gsl_bspline_deriv_workspace_k_get;
*swig_k_set = *Math::GSL::BSplinec::gsl_bspline_deriv_workspace_k_set;
*swig_A_get = *Math::GSL::BSplinec::gsl_bspline_deriv_workspace_A_get;
*swig_A_set = *Math::GSL::BSplinec::gsl_bspline_deriv_workspace_A_set;
*swig_dB_get = *Math::GSL::BSplinec::gsl_bspline_deriv_workspace_dB_get;
*swig_dB_set = *Math::GSL::BSplinec::gsl_bspline_deriv_workspace_dB_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::BSplinec::new_gsl_bspline_deriv_workspace(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::BSplinec::delete_gsl_bspline_deriv_workspace($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package Math::GSL::BSpline;

*GSL_MAJOR_VERSION = *Math::GSL::BSplinec::GSL_MAJOR_VERSION;
*GSL_MINOR_VERSION = *Math::GSL::BSplinec::GSL_MINOR_VERSION;
*GSL_POSZERO = *Math::GSL::BSplinec::GSL_POSZERO;
*GSL_NEGZERO = *Math::GSL::BSplinec::GSL_NEGZERO;

@EXPORT_OK = qw/
               gsl_bspline_alloc 
               gsl_bspline_free 
               gsl_bspline_ncoeffs 
               gsl_bspline_order 
               gsl_bspline_nbreak 
               gsl_bspline_breakpoint 
               gsl_bspline_knots 
               gsl_bspline_knots_uniform 
               gsl_bspline_eval 
             /;
%EXPORT_TAGS = ( all => [ @EXPORT_OK ] );

__END__

=head1 NAME

Math::GSL::BSpline - Functions for the computation of smoothing basis splines

=head1 SYNOPSIS

    use Math::GSL::BSpline qw/:all/;

=head1 DESCRIPTION

=over

=item gsl_bspline_alloc($k, $nbreak) 

This function allocates a workspace for computing B-splines of order $k. The
number of breakpoints is given by $nbreak. This leads to n = $nbreak + $k - 2
basis functions. Cubic B-splines are specified by $k = 4.

=item gsl_bspline_free($w)

This function frees the memory associated with the workspace $w.

=item gsl_bspline_ncoeffs($w) 

This function returns the number of B-spline coefficients given by n = nbreak + k - 2. 

=item gsl_bspline_order 

=item gsl_bspline_nbreak 

=item gsl_bspline_breakpoint 

=item gsl_bspline_knots($breakpts, $w) 

This function computes the knots associated with the given breakpoints inside
the vector $breakpts and stores them internally in $w->{knots}.

=item gsl_bspline_knots_uniform($a, $b, $w) 

This function assumes uniformly spaced breakpoints on [$a,$b] and constructs
the corresponding knot vector using the previously specified nbreak parameter.
The knots are stored in $w->{knots}. 

=item gsl_bspline_eval($x, $B, $w)

This function evaluates all B-spline basis functions at the position $x and
stores them in the vector $B, so that the ith element of $B is B_i($x). $B must
be of length n = $nbreak + $k - 2. This value may also be obtained by calling
gsl_bspline_ncoeffs. It is far more efficient to compute all of the basis
functions at once than to compute them individually, due to the nature of the
defining recurrence relation.

For more informations on the functions, we refer you to the GSL offcial documentation: 
http://www.gnu.org/software/gsl/manual/html_node/

=back

=head1 EXAMPLES

Coming soon.

=head1 AUTHORS

Jonathan "Duke" Leto <jonathan@leto.net> and Thierry Moisan <thierry.moisan@gmail.com>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2008-2011 Jonathan "Duke" Leto and Thierry Moisan

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

1;
